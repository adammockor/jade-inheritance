// Generated by CoffeeScript 1.10.0
(function() {
  var Parser, fs, glob, nodePath, pugLex, pugParser, pugWalk, resolvePath;

  nodePath = require('path');

  fs = require('fs');

  glob = require('glob');

  pugLex = require('pug-lexer');

  pugParser = require('pug-parser');

  pugWalk = require('pug-walk');

  resolvePath = function(path, file, basedir, purpose) {
    if (path[0] !== '/' && !file) {
      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');
    }
    if (path[0] === '/' && !basedir) {
      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');
    }
    path = nodePath.join((path[0] === '/' ? basedir : nodePath.dirname(file)), path);
    if (nodePath.basename(path).indexOf('.') === -1) {
      path += '.jade';
    }
    return path;
  };

  Parser = (function() {
    function Parser(filename, directory, options) {
      var files;
      this.filename = filename;
      this.directory = directory;
      this.options = options;
      this.extension = '';
      if (this.options.extension) {
        this.extension = this.options.extension.indexOf('.') > -1 ? this.options.extension : '.' + this.options.extension;
      } else {
        this.extension = '.pug';
      }
      this.cache = {};
      this.files = {};
      filename = nodePath.relative(this.options.basedir, filename);
      this.addFile(filename);
      files = glob.sync(this.directory + "/**/*" + this.extension);
      this.tree = this.getInheritance(filename, files);
      files = this.files;
      this.files = [];
      for (filename in files) {
        this.files.push(filename);
      }
      return this;
    }

    Parser.prototype.getInheritance = function(filename, files) {
      var branch, file, fn, i, len;
      this.addFile(filename);
      branch = {};
      if (branch[filename] == null) {
        branch[filename] = {};
      }
      fn = (function(_this) {
        return function(file) {
          var base, e, error, relativeFile, string;
          file = nodePath.normalize(file);
          relativeFile = nodePath.relative(_this.options.basedir, file);
          file = nodePath.join(_this.options.basedir, relativeFile);
          if ((base = _this.cache)[file] == null) {
            base[file] = {};
          }
          if (_this.cache[file].string != null) {
            string = _this.cache[file].string;
          } else {
            string = _this.cache[file].string = fs.readFileSync(file, 'utf8');
          }
          try {
            return pugWalk(pugParser(pugLex(string, file)), function(node) {
              var base1, inheritance, newFile, path, relationship, type;
              type = node.type;
              switch (type) {
                case 'Extends':
                case 'RawInclude':
                  path = resolvePath(node.file.path, file, _this.options.basedir, type);
                  if (path === nodePath.join(_this.options.basedir, filename)) {
                    if (type === 'Extends') {
                      relationship = 'extendedBy';
                    } else if (type === 'RawInclude') {
                      relationship = 'includedBy';
                    }
                    newFile = {};
                    if (_this.cache[file].inheritance != null) {
                      inheritance = _this.cache[file].inheritance;
                    } else {
                      inheritance = _this.cache[file].inheritance = _this.getInheritance(relativeFile, files);
                    }
                    newFile = inheritance;
                    if ((base1 = branch[filename])[relationship] == null) {
                      base1[relationship] = [];
                    }
                    return branch[filename][relationship].push(newFile);
                  }
              }
            });
          } catch (error) {
            e = error;
            throw e;
          }
        };
      })(this);
      for (i = 0, len = files.length; i < len; i++) {
        file = files[i];
        fn(file);
      }
      return branch;
    };

    Parser.prototype.addFile = function(filename) {
      if (this.files[filename] == null) {
        return this.files[filename] = null;
      }
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
